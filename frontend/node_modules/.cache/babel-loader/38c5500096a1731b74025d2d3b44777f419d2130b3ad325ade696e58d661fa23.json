{"ast":null,"code":"import { isTruthy } from \"./chunk-GGFRMWFO.mjs\";\nimport { parsePublishableKey } from \"./chunk-IV7BOO4U.mjs\";\nimport { __privateAdd, __privateGet, __privateMethod, __privateSet } from \"./chunk-7ELT755Q.mjs\";\n\n// src/telemetry/throttler.ts\nvar DEFAULT_CACHE_TTL_MS = 864e5;\nvar _storageKey, _cacheTtl, _TelemetryEventThrottler_instances, generateKey_fn, cache_get, isValidBrowser_get;\nvar TelemetryEventThrottler = class {\n  constructor() {\n    __privateAdd(this, _TelemetryEventThrottler_instances);\n    __privateAdd(this, _storageKey, \"clerk_telemetry_throttler\");\n    __privateAdd(this, _cacheTtl, DEFAULT_CACHE_TTL_MS);\n  }\n  isEventThrottled(payload) {\n    if (!__privateGet(this, _TelemetryEventThrottler_instances, isValidBrowser_get)) {\n      return false;\n    }\n    const now = Date.now();\n    const key = __privateMethod(this, _TelemetryEventThrottler_instances, generateKey_fn).call(this, payload);\n    const entry = __privateGet(this, _TelemetryEventThrottler_instances, cache_get)?.[key];\n    if (!entry) {\n      const updatedCache = {\n        ...__privateGet(this, _TelemetryEventThrottler_instances, cache_get),\n        [key]: now\n      };\n      localStorage.setItem(__privateGet(this, _storageKey), JSON.stringify(updatedCache));\n    }\n    const shouldInvalidate = entry && now - entry > __privateGet(this, _cacheTtl);\n    if (shouldInvalidate) {\n      const updatedCache = __privateGet(this, _TelemetryEventThrottler_instances, cache_get);\n      delete updatedCache[key];\n      localStorage.setItem(__privateGet(this, _storageKey), JSON.stringify(updatedCache));\n    }\n    return !!entry;\n  }\n};\n_storageKey = new WeakMap();\n_cacheTtl = new WeakMap();\n_TelemetryEventThrottler_instances = new WeakSet();\n/**\n * Generates a consistent unique key for telemetry events by sorting payload properties.\n * This ensures that payloads with identical content in different orders produce the same key.\n */\ngenerateKey_fn = function (event) {\n  const {\n    sk: _sk,\n    pk: _pk,\n    payload,\n    ...rest\n  } = event;\n  const sanitizedEvent = {\n    ...payload,\n    ...rest\n  };\n  return JSON.stringify(Object.keys({\n    ...payload,\n    ...rest\n  }).sort().map(key => sanitizedEvent[key]));\n};\ncache_get = function () {\n  const cacheString = localStorage.getItem(__privateGet(this, _storageKey));\n  if (!cacheString) {\n    return {};\n  }\n  return JSON.parse(cacheString);\n};\nisValidBrowser_get = function () {\n  if (typeof window === \"undefined\") {\n    return false;\n  }\n  const storage = window.localStorage;\n  if (!storage) {\n    return false;\n  }\n  try {\n    const testKey = \"test\";\n    storage.setItem(testKey, testKey);\n    storage.removeItem(testKey);\n    return true;\n  } catch (err) {\n    const isQuotaExceededError = err instanceof DOMException && (\n    // Check error names for different browsers\n    err.name === \"QuotaExceededError\" || err.name === \"NS_ERROR_DOM_QUOTA_REACHED\");\n    if (isQuotaExceededError && storage.length > 0) {\n      storage.removeItem(__privateGet(this, _storageKey));\n    }\n    return false;\n  }\n};\n\n// src/telemetry/collector.ts\nfunction isWindowClerkWithMetadata(clerk) {\n  return typeof clerk === \"object\" && clerk !== null && \"constructor\" in clerk && typeof clerk.constructor === \"function\";\n}\nvar VALID_LOG_LEVELS = /* @__PURE__ */new Set([\"error\", \"warn\", \"info\", \"debug\", \"trace\"]);\nvar DEFAULT_CONFIG = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: \"https://clerk-telemetry.com\"\n};\nvar _config, _eventThrottler, _metadata, _buffer, _pendingFlush, _TelemetryCollector_instances, shouldRecord_fn, shouldRecordLog_fn, shouldBeSampled_fn, scheduleFlush_fn, flush_fn, logEvent_fn, getSDKMetadata_fn, preparePayload_fn, sanitizeContext_fn;\nvar TelemetryCollector = class {\n  constructor(options) {\n    __privateAdd(this, _TelemetryCollector_instances);\n    __privateAdd(this, _config);\n    __privateAdd(this, _eventThrottler);\n    __privateAdd(this, _metadata, {});\n    __privateAdd(this, _buffer, []);\n    __privateAdd(this, _pendingFlush, null);\n    __privateSet(this, _config, {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint\n    });\n    if (!options.clerkVersion && typeof window === \"undefined\") {\n      __privateGet(this, _metadata).clerkVersion = \"\";\n    } else {\n      __privateGet(this, _metadata).clerkVersion = options.clerkVersion ?? \"\";\n    }\n    __privateGet(this, _metadata).sdk = options.sdk;\n    __privateGet(this, _metadata).sdkVersion = options.sdkVersion;\n    __privateGet(this, _metadata).publishableKey = options.publishableKey ?? \"\";\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      __privateGet(this, _metadata).instanceType = parsedKey.instanceType;\n    }\n    if (options.secretKey) {\n      __privateGet(this, _metadata).secretKey = options.secretKey.substring(0, 16);\n    }\n    __privateSet(this, _eventThrottler, new TelemetryEventThrottler());\n  }\n  get isEnabled() {\n    if (__privateGet(this, _metadata).instanceType !== \"development\") {\n      return false;\n    }\n    if (__privateGet(this, _config).disabled || typeof process !== \"undefined\" && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED)) {\n      return false;\n    }\n    if (typeof window !== \"undefined\" && !!window?.navigator?.webdriver) {\n      return false;\n    }\n    return true;\n  }\n  get isDebug() {\n    return __privateGet(this, _config).debug || typeof process !== \"undefined\" && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG);\n  }\n  record(event) {\n    try {\n      const preparedPayload = __privateMethod(this, _TelemetryCollector_instances, preparePayload_fn).call(this, event.event, event.payload);\n      __privateMethod(this, _TelemetryCollector_instances, logEvent_fn).call(this, preparedPayload.event, preparedPayload);\n      if (!__privateMethod(this, _TelemetryCollector_instances, shouldRecord_fn).call(this, preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n      __privateGet(this, _buffer).push({\n        kind: \"event\",\n        value: preparedPayload\n      });\n      __privateMethod(this, _TelemetryCollector_instances, scheduleFlush_fn).call(this);\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry event\", error);\n    }\n  }\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry) {\n    try {\n      if (!__privateMethod(this, _TelemetryCollector_instances, shouldRecordLog_fn).call(this, entry)) {\n        return;\n      }\n      const levelIsValid = typeof entry?.level === \"string\" && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === \"string\" && entry.message.trim().length > 0;\n      let normalizedTimestamp = null;\n      const timestampInput = entry?.timestamp;\n      if (typeof timestampInput === \"number\" || typeof timestampInput === \"string\") {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== \"undefined\") {\n          console.warn(\"[clerk/telemetry] Dropping invalid telemetry log entry\", {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null\n          });\n        }\n        return;\n      }\n      const sdkMetadata = __privateMethod(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);\n      const logData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: __privateGet(this, _metadata).clerkVersion ?? \"\",\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: __privateGet(this, _metadata).publishableKey || null,\n        payload: __privateMethod(this, _TelemetryCollector_instances, sanitizeContext_fn).call(this, entry.context)\n      };\n      __privateGet(this, _buffer).push({\n        kind: \"log\",\n        value: logData\n      });\n      __privateMethod(this, _TelemetryCollector_instances, scheduleFlush_fn).call(this);\n    } catch (error) {\n      console.error(\"[clerk/telemetry] Error recording telemetry log entry\", error);\n    }\n  }\n};\n_config = new WeakMap();\n_eventThrottler = new WeakMap();\n_metadata = new WeakMap();\n_buffer = new WeakMap();\n_pendingFlush = new WeakMap();\n_TelemetryCollector_instances = new WeakSet();\nshouldRecord_fn = function (preparedPayload, eventSamplingRate) {\n  return this.isEnabled && !this.isDebug && __privateMethod(this, _TelemetryCollector_instances, shouldBeSampled_fn).call(this, preparedPayload, eventSamplingRate);\n};\nshouldRecordLog_fn = function (_entry) {\n  return true;\n};\nshouldBeSampled_fn = function (preparedPayload, eventSamplingRate) {\n  const randomSeed = Math.random();\n  const toBeSampled = randomSeed <= __privateGet(this, _config).samplingRate && (__privateGet(this, _config).perEventSampling === false || typeof eventSamplingRate === \"undefined\" || randomSeed <= eventSamplingRate);\n  if (!toBeSampled) {\n    return false;\n  }\n  return !__privateGet(this, _eventThrottler).isEventThrottled(preparedPayload);\n};\nscheduleFlush_fn = function () {\n  if (typeof window === \"undefined\") {\n    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);\n    return;\n  }\n  const isBufferFull = __privateGet(this, _buffer).length >= __privateGet(this, _config).maxBufferSize;\n  if (isBufferFull) {\n    if (__privateGet(this, _pendingFlush)) {\n      if (typeof cancelIdleCallback !== \"undefined\") {\n        cancelIdleCallback(Number(__privateGet(this, _pendingFlush)));\n      } else {\n        clearTimeout(Number(__privateGet(this, _pendingFlush)));\n      }\n    }\n    __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);\n    return;\n  }\n  if (__privateGet(this, _pendingFlush)) {\n    return;\n  }\n  if (\"requestIdleCallback\" in window) {\n    __privateSet(this, _pendingFlush, requestIdleCallback(() => {\n      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);\n      __privateSet(this, _pendingFlush, null);\n    }));\n  } else {\n    __privateSet(this, _pendingFlush, setTimeout(() => {\n      __privateMethod(this, _TelemetryCollector_instances, flush_fn).call(this);\n      __privateSet(this, _pendingFlush, null);\n    }, 0));\n  }\n};\nflush_fn = function () {\n  const itemsToSend = [...__privateGet(this, _buffer)];\n  __privateSet(this, _buffer, []);\n  __privateSet(this, _pendingFlush, null);\n  if (itemsToSend.length === 0) {\n    return;\n  }\n  const eventsToSend = itemsToSend.filter(item => item.kind === \"event\").map(item => item.value);\n  const logsToSend = itemsToSend.filter(item => item.kind === \"log\").map(item => item.value);\n  if (eventsToSend.length > 0) {\n    const eventsUrl = new URL(\"/v1/event\", __privateGet(this, _config).endpoint);\n    fetch(eventsUrl, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      keepalive: true,\n      method: \"POST\",\n      // TODO: We send an array here with that idea that we can eventually send multiple events.\n      body: JSON.stringify({\n        events: eventsToSend\n      })\n    }).catch(() => void 0);\n  }\n  if (logsToSend.length > 0) {\n    const logsUrl = new URL(\"/v1/logs\", __privateGet(this, _config).endpoint);\n    fetch(logsUrl, {\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      keepalive: true,\n      method: \"POST\",\n      body: JSON.stringify({\n        logs: logsToSend\n      })\n    }).catch(() => void 0);\n  }\n};\n/**\n * If running in debug mode, log the event and its payload to the console.\n */\nlogEvent_fn = function (event, payload) {\n  if (!this.isDebug) {\n    return;\n  }\n  if (typeof console.groupCollapsed !== \"undefined\") {\n    console.groupCollapsed(\"[clerk/telemetry]\", event);\n    console.log(payload);\n    console.groupEnd();\n  } else {\n    console.log(\"[clerk/telemetry]\", event, payload);\n  }\n};\n/**\n * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n *\n * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n */\ngetSDKMetadata_fn = function () {\n  const sdkMetadata = {\n    name: __privateGet(this, _metadata).sdk,\n    version: __privateGet(this, _metadata).sdkVersion\n  };\n  if (typeof window !== \"undefined\") {\n    const windowWithClerk = window;\n    if (windowWithClerk.Clerk) {\n      const windowClerk = windowWithClerk.Clerk;\n      if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n        const {\n          name,\n          version\n        } = windowClerk.constructor.sdkMetadata;\n        if (name !== void 0) {\n          sdkMetadata.name = name;\n        }\n        if (version !== void 0) {\n          sdkMetadata.version = version;\n        }\n      }\n    }\n  }\n  return sdkMetadata;\n};\n/**\n * Append relevant metadata from the Clerk singleton to the event payload.\n */\npreparePayload_fn = function (event, payload) {\n  const sdkMetadata = __privateMethod(this, _TelemetryCollector_instances, getSDKMetadata_fn).call(this);\n  return {\n    event,\n    cv: __privateGet(this, _metadata).clerkVersion ?? \"\",\n    it: __privateGet(this, _metadata).instanceType ?? \"\",\n    sdk: sdkMetadata.name,\n    sdkv: sdkMetadata.version,\n    ...(__privateGet(this, _metadata).publishableKey ? {\n      pk: __privateGet(this, _metadata).publishableKey\n    } : {}),\n    ...(__privateGet(this, _metadata).secretKey ? {\n      sk: __privateGet(this, _metadata).secretKey\n    } : {}),\n    payload\n  };\n};\n/**\n * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n * values or null when the input is missing or not serializable. Arrays are not accepted.\n */\nsanitizeContext_fn = function (context) {\n  if (context === null || typeof context === \"undefined\") {\n    return null;\n  }\n  if (typeof context !== \"object\") {\n    return null;\n  }\n  try {\n    const cleaned = JSON.parse(JSON.stringify(context));\n    if (cleaned && typeof cleaned === \"object\" && !Array.isArray(cleaned)) {\n      return cleaned;\n    }\n    return null;\n  } catch {\n    return null;\n  }\n};\n\n// src/telemetry/events/component-mounted.ts\nvar EVENT_COMPONENT_MOUNTED = \"COMPONENT_MOUNTED\";\nvar EVENT_COMPONENT_OPENED = \"COMPONENT_OPENED\";\nvar EVENT_SAMPLING_RATE = 0.1;\nfunction createPrebuiltComponentEvent(event) {\n  return function (component, props, additionalPayload) {\n    return {\n      event,\n      eventSamplingRate: EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload\n      }\n    };\n  };\n}\nfunction eventPrebuiltComponentMounted(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\nfunction eventPrebuiltComponentOpened(component, props, additionalPayload) {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\nfunction eventComponentMounted(component, props = {}) {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      ...props\n    }\n  };\n}\n\n// src/telemetry/events/method-called.ts\nvar EVENT_METHOD_CALLED = \"METHOD_CALLED\";\nvar EVENT_SAMPLING_RATE2 = 0.1;\nfunction eventMethodCalled(method, payload) {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE2,\n    payload: {\n      method,\n      ...payload\n    }\n  };\n}\n\n// src/telemetry/events/framework-metadata.ts\nvar EVENT_FRAMEWORK_METADATA = \"FRAMEWORK_METADATA\";\nvar EVENT_SAMPLING_RATE3 = 0.1;\nfunction eventFrameworkMetadata(payload) {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE3,\n    payload\n  };\n}\n\n// src/telemetry/events/theme-usage.ts\nvar EVENT_THEME_USAGE = \"THEME_USAGE\";\nvar EVENT_SAMPLING_RATE4 = 1;\nfunction eventThemeUsage(appearance) {\n  const payload = analyzeThemeUsage(appearance);\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE4,\n    payload\n  };\n}\nfunction analyzeThemeUsage(appearance) {\n  if (!appearance || typeof appearance !== \"object\") {\n    return {};\n  }\n  const themeProperty = appearance.theme || appearance.baseTheme;\n  if (!themeProperty) {\n    return {};\n  }\n  let themeName;\n  if (Array.isArray(themeProperty)) {\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n  return {\n    themeName\n  };\n}\nfunction extractThemeName(theme) {\n  if (typeof theme === \"string\") {\n    return theme;\n  }\n  if (typeof theme === \"object\" && theme !== null) {\n    if (\"name\" in theme && typeof theme.name === \"string\") {\n      return theme.name;\n    }\n  }\n  return void 0;\n}\nexport { TelemetryCollector, eventPrebuiltComponentMounted, eventPrebuiltComponentOpened, eventComponentMounted, eventMethodCalled, eventFrameworkMetadata, EVENT_THEME_USAGE, EVENT_SAMPLING_RATE4 as EVENT_SAMPLING_RATE, eventThemeUsage };","map":{"version":3,"names":["DEFAULT_CACHE_TTL_MS","_storageKey","_cacheTtl","_TelemetryEventThrottler_instances","generateKey_fn","cache_get","isValidBrowser_get","TelemetryEventThrottler","constructor","__privateAdd","isEventThrottled","payload","__privateGet","now","Date","key","__privateMethod","call","entry","updatedCache","localStorage","setItem","JSON","stringify","shouldInvalidate","WeakMap","WeakSet","event","sk","_sk","pk","_pk","rest","sanitizedEvent","Object","keys","sort","map","cacheString","getItem","parse","window","storage","testKey","removeItem","err","isQuotaExceededError","DOMException","name","length","isWindowClerkWithMetadata","clerk","VALID_LOG_LEVELS","Set","DEFAULT_CONFIG","samplingRate","maxBufferSize","endpoint","_config","_eventThrottler","_metadata","_buffer","_pendingFlush","_TelemetryCollector_instances","shouldRecord_fn","shouldRecordLog_fn","shouldBeSampled_fn","scheduleFlush_fn","flush_fn","logEvent_fn","getSDKMetadata_fn","preparePayload_fn","sanitizeContext_fn","TelemetryCollector","options","__privateSet","perEventSampling","disabled","debug","clerkVersion","sdk","sdkVersion","publishableKey","parsedKey","parsePublishableKey","instanceType","secretKey","substring","isEnabled","process","env","isTruthy","CLERK_TELEMETRY_DISABLED","navigator","webdriver","isDebug","CLERK_TELEMETRY_DEBUG","record","preparedPayload","eventSamplingRate","push","kind","value","error","console","recordLog","levelIsValid","level","has","messageIsValid","message","trim","normalizedTimestamp","timestampInput","timestamp","candidate","Number","isNaN","getTime","warn","timestampIsValid","sdkMetadata","logData","sdkv","version","cv","lvl","msg","ts","toISOString","context","_entry","randomSeed","Math","random","toBeSampled","isBufferFull","cancelIdleCallback","clearTimeout","requestIdleCallback","setTimeout","itemsToSend","eventsToSend","filter","item","logsToSend","eventsUrl","URL","fetch","headers","keepalive","method","body","events","catch","logsUrl","logs","groupCollapsed","log","groupEnd","windowWithClerk","Clerk","windowClerk","it","cleaned","Array","isArray","EVENT_COMPONENT_MOUNTED","EVENT_COMPONENT_OPENED","EVENT_SAMPLING_RATE","createPrebuiltComponentEvent","component","props","additionalPayload","appearanceProp","Boolean","appearance","baseTheme","elements","variables","eventPrebuiltComponentMounted","eventPrebuiltComponentOpened","eventComponentMounted","EVENT_METHOD_CALLED","EVENT_SAMPLING_RATE2","eventMethodCalled","EVENT_FRAMEWORK_METADATA","EVENT_SAMPLING_RATE3","eventFrameworkMetadata","EVENT_THEME_USAGE","EVENT_SAMPLING_RATE4","eventThemeUsage","analyzeThemeUsage","themeProperty","theme","themeName","extractThemeName"],"sources":["D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\throttler.ts","D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\collector.ts","D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\component-mounted.ts","D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\method-called.ts","D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\framework-metadata.ts","D:\\hidc project\\hidc project\\frontend\\node_modules\\@clerk\\shared\\src\\telemetry\\events\\theme-usage.ts"],"sourcesContent":["import type { TelemetryEvent } from '@clerk/types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Manages throttling for telemetry events using the browser's localStorage to\n * mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #storageKey = 'clerk_telemetry_throttler';\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    if (!this.#isValidBrowser) {\n      return false;\n    }\n\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache?.[key];\n\n    if (!entry) {\n      const updatedCache = {\n        ...this.#cache,\n        [key]: now,\n      };\n\n      localStorage.setItem(this.#storageKey, JSON.stringify(updatedCache));\n    }\n\n    const shouldInvalidate = entry && now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      const updatedCache = this.#cache;\n      delete updatedCache[key];\n\n      localStorage.setItem(this.#storageKey, JSON.stringify(updatedCache));\n    }\n\n    return !!entry;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n\n  get #cache(): Record<string, TtlInMilliseconds> | undefined {\n    const cacheString = localStorage.getItem(this.#storageKey);\n\n    if (!cacheString) {\n      return {};\n    }\n\n    return JSON.parse(cacheString);\n  }\n\n  /**\n   * Checks if the browser's localStorage is supported and writable.\n   *\n   * If any of these operations fail, it indicates that localStorage is either\n   * not supported or not writable (e.g., in cases where the storage is full or\n   * the browser is in a privacy mode that restricts localStorage usage).\n   */\n  get #isValidBrowser(): boolean {\n    if (typeof window === 'undefined') {\n      return false;\n    }\n\n    const storage = window.localStorage;\n    if (!storage) {\n      return false;\n    }\n\n    try {\n      const testKey = 'test';\n      storage.setItem(testKey, testKey);\n      storage.removeItem(testKey);\n\n      return true;\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && storage.length > 0) {\n        storage.removeItem(this.#storageKey);\n      }\n\n      return false;\n    }\n  }\n}\n","/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '@clerk/types';\n\nimport { parsePublishableKey } from '../keys';\nimport { isTruthy } from '../underscore';\nimport { TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    this.#eventThrottler = new TelemetryEventThrottler();\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate: EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n","import type { TelemetryEventRaw } from '@clerk/types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n","import type { Appearance, BaseTheme, TelemetryEventRaw } from '@clerk/types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n"],"mappings":";;;;;AAIA,IAAMA,oBAAA,GAAuB;AAJ7B,IAAAC,WAAA,EAAAC,SAAA,EAAAC,kCAAA,EAAAC,cAAA,EAAAC,SAAA,EAAAC,kBAAA;AAUO,IAAMC,uBAAA,GAAN,MAA8B;EAA9BC,YAAA;IAAAC,YAAA,OAAAN,kCAAA;IACLM,YAAA,OAAAR,WAAA,EAAc;IACdQ,YAAA,OAAAP,SAAA,EAAYF,oBAAA;EAAA;EAEZU,iBAAiBC,OAAA,EAAkC;IACjD,IAAI,CAACC,YAAA,OAAKT,kCAAA,EAAAG,kBAAA,GAAiB;MACzB,OAAO;IACT;IAEA,MAAMO,GAAA,GAAMC,IAAA,CAAKD,GAAA,CAAI;IACrB,MAAME,GAAA,GAAMC,eAAA,OAAKb,kCAAA,EAAAC,cAAA,EAALa,IAAA,OAAkBN,OAAA;IAC9B,MAAMO,KAAA,GAAQN,YAAA,OAAKT,kCAAA,EAAAE,SAAA,IAASU,GAAG;IAE/B,IAAI,CAACG,KAAA,EAAO;MACV,MAAMC,YAAA,GAAe;QACnB,GAAGP,YAAA,OAAKT,kCAAA,EAAAE,SAAA;QACR,CAACU,GAAG,GAAGF;MACT;MAEAO,YAAA,CAAaC,OAAA,CAAQT,YAAA,OAAKX,WAAA,GAAaqB,IAAA,CAAKC,SAAA,CAAUJ,YAAY,CAAC;IACrE;IAEA,MAAMK,gBAAA,GAAmBN,KAAA,IAASL,GAAA,GAAMK,KAAA,GAAQN,YAAA,OAAKV,SAAA;IACrD,IAAIsB,gBAAA,EAAkB;MACpB,MAAML,YAAA,GAAeP,YAAA,OAAKT,kCAAA,EAAAE,SAAA;MAC1B,OAAOc,YAAA,CAAaJ,GAAG;MAEvBK,YAAA,CAAaC,OAAA,CAAQT,YAAA,OAAKX,WAAA,GAAaqB,IAAA,CAAKC,SAAA,CAAUJ,YAAY,CAAC;IACrE;IAEA,OAAO,CAAC,CAACD,KAAA;EACX;AAsEF;AApGEjB,WAAA,OAAAwB,OAAA;AACAvB,SAAA,OAAAuB,OAAA;AAFKtB,kCAAA,OAAAuB,OAAA;AAAA;AAAA;AAAA;AAAA;AAqCLtB,cAAA,GAAY,SAAAA,CAACuB,KAAA,EAA+B;EAC1C,MAAM;IAAEC,EAAA,EAAIC,GAAA;IAAKC,EAAA,EAAIC,GAAA;IAAKpB,OAAA;IAAS,GAAGqB;EAAK,IAAIL,KAAA;EAE/C,MAAMM,cAAA,GAA4F;IAChG,GAAGtB,OAAA;IACH,GAAGqB;EACL;EAEA,OAAOV,IAAA,CAAKC,SAAA,CACVW,MAAA,CAAOC,IAAA,CAAK;IACV,GAAGxB,OAAA;IACH,GAAGqB;EACL,CAAC,EACEI,IAAA,CAAK,EACLC,GAAA,CAAItB,GAAA,IAAOkB,cAAA,CAAelB,GAAG,CAAC,CACnC;AACF;AAEIV,SAAA,GAAM,SAAAA,CAAA,EAAkD;EAC1D,MAAMiC,WAAA,GAAclB,YAAA,CAAamB,OAAA,CAAQ3B,YAAA,OAAKX,WAAA,CAAW;EAEzD,IAAI,CAACqC,WAAA,EAAa;IAChB,OAAO,CAAC;EACV;EAEA,OAAOhB,IAAA,CAAKkB,KAAA,CAAMF,WAAW;AAC/B;AASIhC,kBAAA,GAAe,SAAAA,CAAA,EAAY;EAC7B,IAAI,OAAOmC,MAAA,KAAW,aAAa;IACjC,OAAO;EACT;EAEA,MAAMC,OAAA,GAAUD,MAAA,CAAOrB,YAAA;EACvB,IAAI,CAACsB,OAAA,EAAS;IACZ,OAAO;EACT;EAEA,IAAI;IACF,MAAMC,OAAA,GAAU;IAChBD,OAAA,CAAQrB,OAAA,CAAQsB,OAAA,EAASA,OAAO;IAChCD,OAAA,CAAQE,UAAA,CAAWD,OAAO;IAE1B,OAAO;EACT,SAASE,GAAA,EAAc;IACrB,MAAMC,oBAAA,GACJD,GAAA,YAAeE,YAAA;IAAA;IAEdF,GAAA,CAAIG,IAAA,KAAS,wBAAwBH,GAAA,CAAIG,IAAA,KAAS;IAErD,IAAIF,oBAAA,IAAwBJ,OAAA,CAAQO,MAAA,GAAS,GAAG;MAC9CP,OAAA,CAAQE,UAAA,CAAWhC,YAAA,OAAKX,WAAA,CAAW;IACrC;IAEA,OAAO;EACT;AACF;;;ACrEF,SAASiD,0BAA0BC,KAAA,EAAyE;EAC1G,OACE,OAAOA,KAAA,KAAU,YAAYA,KAAA,KAAU,QAAQ,iBAAiBA,KAAA,IAAS,OAAOA,KAAA,CAAM3C,WAAA,KAAgB;AAE1G;AA6CA,IAAM4C,gBAAA,GAAmB,mBAAIC,GAAA,CAAY,CAAC,SAAS,QAAQ,QAAQ,SAAS,OAAO,CAAC;AAEpF,IAAMC,cAAA,GAAoD;EACxDC,YAAA,EAAc;EACdC,aAAA,EAAe;EAAA;EAAA;EAAA;EAIfC,QAAA,EAAU;AACZ;AAnGA,IAAAC,OAAA,EAAAC,eAAA,EAAAC,SAAA,EAAAC,OAAA,EAAAC,aAAA,EAAAC,6BAAA,EAAAC,eAAA,EAAAC,kBAAA,EAAAC,kBAAA,EAAAC,gBAAA,EAAAC,QAAA,EAAAC,WAAA,EAAAC,iBAAA,EAAAC,iBAAA,EAAAC,kBAAA;AAqGO,IAAMC,kBAAA,GAAN,MAAgE;EAOrEjE,YAAYkE,OAAA,EAAoC;IAP3CjE,YAAA,OAAAsD,6BAAA;IACLtD,YAAA,OAAAiD,OAAA;IACAjD,YAAA,OAAAkD,eAAA;IACAlD,YAAA,OAAAmD,SAAA,EAA+B,CAAC;IAChCnD,YAAA,OAAAoD,OAAA,EAAiC,EAAC;IAClCpD,YAAA,OAAAqD,aAAA,EAA+D;IAG7Da,YAAA,OAAKjB,OAAA,EAAU;MACbF,aAAA,EAAekB,OAAA,CAAQlB,aAAA,IAAiBF,cAAA,CAAeE,aAAA;MACvDD,YAAA,EAAcmB,OAAA,CAAQnB,YAAA,IAAgBD,cAAA,CAAeC,YAAA;MACrDqB,gBAAA,EAAkBF,OAAA,CAAQE,gBAAA,IAAoB;MAC9CC,QAAA,EAAUH,OAAA,CAAQG,QAAA,IAAY;MAC9BC,KAAA,EAAOJ,OAAA,CAAQI,KAAA,IAAS;MACxBrB,QAAA,EAAUH,cAAA,CAAeG;IAC3B;IAEA,IAAI,CAACiB,OAAA,CAAQK,YAAA,IAAgB,OAAOtC,MAAA,KAAW,aAAa;MAE1D7B,YAAA,OAAKgD,SAAA,EAAUmB,YAAA,GAAe;IAChC,OAAO;MACLnE,YAAA,OAAKgD,SAAA,EAAUmB,YAAA,GAAeL,OAAA,CAAQK,YAAA,IAAgB;IACxD;IAIAnE,YAAA,OAAKgD,SAAA,EAAUoB,GAAA,GAAMN,OAAA,CAAQM,GAAA;IAE7BpE,YAAA,OAAKgD,SAAA,EAAUqB,UAAA,GAAaP,OAAA,CAAQO,UAAA;IAEpCrE,YAAA,OAAKgD,SAAA,EAAUsB,cAAA,GAAiBR,OAAA,CAAQQ,cAAA,IAAkB;IAE1D,MAAMC,SAAA,GAAYC,mBAAA,CAAoBV,OAAA,CAAQQ,cAAc;IAC5D,IAAIC,SAAA,EAAW;MACbvE,YAAA,OAAKgD,SAAA,EAAUyB,YAAA,GAAeF,SAAA,CAAUE,YAAA;IAC1C;IAEA,IAAIX,OAAA,CAAQY,SAAA,EAAW;MAErB1E,YAAA,OAAKgD,SAAA,EAAU0B,SAAA,GAAYZ,OAAA,CAAQY,SAAA,CAAUC,SAAA,CAAU,GAAG,EAAE;IAC9D;IAEAZ,YAAA,OAAKhB,eAAA,EAAkB,IAAIpD,uBAAA,CAAwB;EACrD;EAEA,IAAIiF,UAAA,EAAqB;IACvB,IAAI5E,YAAA,OAAKgD,SAAA,EAAUyB,YAAA,KAAiB,eAAe;MACjD,OAAO;IACT;IAIA,IACEzE,YAAA,OAAK8C,OAAA,EAAQmB,QAAA,IACZ,OAAOY,OAAA,KAAY,eAAeA,OAAA,CAAQC,GAAA,IAAOC,QAAA,CAASF,OAAA,CAAQC,GAAA,CAAIE,wBAAwB,GAC/F;MACA,OAAO;IACT;IAKA,IAAI,OAAOnD,MAAA,KAAW,eAAe,CAAC,CAACA,MAAA,EAAQoD,SAAA,EAAWC,SAAA,EAAW;MACnE,OAAO;IACT;IAEA,OAAO;EACT;EAEA,IAAIC,QAAA,EAAmB;IACrB,OACEnF,YAAA,OAAK8C,OAAA,EAAQoB,KAAA,IACZ,OAAOW,OAAA,KAAY,eAAeA,OAAA,CAAQC,GAAA,IAAOC,QAAA,CAASF,OAAA,CAAQC,GAAA,CAAIM,qBAAqB;EAEhG;EAEAC,OAAOtE,KAAA,EAAgC;IACrC,IAAI;MACF,MAAMuE,eAAA,GAAkBlF,eAAA,OAAK+C,6BAAA,EAAAQ,iBAAA,EAALtD,IAAA,OAAqBU,KAAA,CAAMA,KAAA,EAAOA,KAAA,CAAMhB,OAAA;MAEhEK,eAAA,OAAK+C,6BAAA,EAAAM,WAAA,EAALpD,IAAA,OAAeiF,eAAA,CAAgBvE,KAAA,EAAOuE,eAAA;MAEtC,IAAI,CAAClF,eAAA,OAAK+C,6BAAA,EAAAC,eAAA,EAAL/C,IAAA,OAAmBiF,eAAA,EAAiBvE,KAAA,CAAMwE,iBAAA,GAAoB;QACjE;MACF;MAEAvF,YAAA,OAAKiD,OAAA,EAAQuC,IAAA,CAAK;QAAEC,IAAA,EAAM;QAASC,KAAA,EAAOJ;MAAgB,CAAC;MAE3DlF,eAAA,OAAK+C,6BAAA,EAAAI,gBAAA,EAALlD,IAAA;IACF,SAASsF,KAAA,EAAO;MACdC,OAAA,CAAQD,KAAA,CAAM,qDAAqDA,KAAK;IAC1E;EACF;EAAA;AAAA;AAAA;AAAA;AAAA;EAOAE,UAAUvF,KAAA,EAAgC;IACxC,IAAI;MACF,IAAI,CAACF,eAAA,OAAK+C,6BAAA,EAAAE,kBAAA,EAALhD,IAAA,OAAsBC,KAAA,GAAQ;QACjC;MACF;MAEA,MAAMwF,YAAA,GAAe,OAAOxF,KAAA,EAAOyF,KAAA,KAAU,YAAYvD,gBAAA,CAAiBwD,GAAA,CAAI1F,KAAA,CAAMyF,KAAK;MACzF,MAAME,cAAA,GAAiB,OAAO3F,KAAA,EAAO4F,OAAA,KAAY,YAAY5F,KAAA,CAAM4F,OAAA,CAAQC,IAAA,CAAK,EAAE9D,MAAA,GAAS;MAE3F,IAAI+D,mBAAA,GAAmC;MACvC,MAAMC,cAAA,GAA2B/F,KAAA,EAA8CgG,SAAA;MAC/E,IAAI,OAAOD,cAAA,KAAmB,YAAY,OAAOA,cAAA,KAAmB,UAAU;QAC5E,MAAME,SAAA,GAAY,IAAIrG,IAAA,CAAKmG,cAAc;QACzC,IAAI,CAACG,MAAA,CAAOC,KAAA,CAAMF,SAAA,CAAUG,OAAA,CAAQ,CAAC,GAAG;UACtCN,mBAAA,GAAsBG,SAAA;QACxB;MACF;MAEA,IAAI,CAACT,YAAA,IAAgB,CAACG,cAAA,IAAkBG,mBAAA,KAAwB,MAAM;QACpE,IAAI,KAAKjB,OAAA,IAAW,OAAOS,OAAA,KAAY,aAAa;UAClDA,OAAA,CAAQe,IAAA,CAAK,0DAA0D;YACrEb,YAAA;YACAG,cAAA;YACAW,gBAAA,EAAkBR,mBAAA,KAAwB;UAC5C,CAAC;QACH;QACA;MACF;MAEA,MAAMS,WAAA,GAAczG,eAAA,OAAK+C,6BAAA,EAAAO,iBAAA,EAALrD,IAAA;MAEpB,MAAMyG,OAAA,GAA4B;QAChC1C,GAAA,EAAKyC,WAAA,CAAYzE,IAAA;QACjB2E,IAAA,EAAMF,WAAA,CAAYG,OAAA;QAClBC,EAAA,EAAIjH,YAAA,OAAKgD,SAAA,EAAUmB,YAAA,IAAgB;QACnC+C,GAAA,EAAK5G,KAAA,CAAMyF,KAAA;QACXoB,GAAA,EAAK7G,KAAA,CAAM4F,OAAA;QACXkB,EAAA,EAAIhB,mBAAA,CAAoBiB,WAAA,CAAY;QACpCnG,EAAA,EAAIlB,YAAA,OAAKgD,SAAA,EAAUsB,cAAA,IAAkB;QACrCvE,OAAA,EAASK,eAAA,OAAK+C,6BAAA,EAAAS,kBAAA,EAALvD,IAAA,OAAsBC,KAAA,CAAMgH,OAAA;MACvC;MAEAtH,YAAA,OAAKiD,OAAA,EAAQuC,IAAA,CAAK;QAAEC,IAAA,EAAM;QAAOC,KAAA,EAAOoB;MAAQ,CAAC;MAEjD1G,eAAA,OAAK+C,6BAAA,EAAAI,gBAAA,EAALlD,IAAA;IACF,SAASsF,KAAA,EAAO;MACdC,OAAA,CAAQD,KAAA,CAAM,yDAAyDA,KAAK;IAC9E;EACF;AAyMF;AA3VE7C,OAAA,OAAAjC,OAAA;AACAkC,eAAA,OAAAlC,OAAA;AACAmC,SAAA,OAAAnC,OAAA;AACAoC,OAAA,OAAApC,OAAA;AACAqC,aAAA,OAAArC,OAAA;AALKsC,6BAAA,OAAArC,OAAA;AAqJLsC,eAAA,GAAa,SAAAA,CAACkC,eAAA,EAAiCC,iBAAA,EAA4B;EACzE,OAAO,KAAKX,SAAA,IAAa,CAAC,KAAKO,OAAA,IAAW/E,eAAA,OAAK+C,6BAAA,EAAAG,kBAAA,EAALjD,IAAA,OAAsBiF,eAAA,EAAiBC,iBAAA;AACnF;AAEAlC,kBAAA,GAAgB,SAAAA,CAACkE,MAAA,EAAoC;EAEnD,OAAO;AACT;AAEAjE,kBAAA,GAAgB,SAAAA,CAACgC,eAAA,EAAiCC,iBAAA,EAA4B;EAC5E,MAAMiC,UAAA,GAAaC,IAAA,CAAKC,MAAA,CAAO;EAE/B,MAAMC,WAAA,GACJH,UAAA,IAAcxH,YAAA,OAAK8C,OAAA,EAAQH,YAAA,KAC1B3C,YAAA,OAAK8C,OAAA,EAAQkB,gBAAA,KAAqB,SACjC,OAAOuB,iBAAA,KAAsB,eAC7BiC,UAAA,IAAcjC,iBAAA;EAElB,IAAI,CAACoC,WAAA,EAAa;IAChB,OAAO;EACT;EAEA,OAAO,CAAC3H,YAAA,OAAK+C,eAAA,EAAgBjD,gBAAA,CAAiBwF,eAAe;AAC/D;AAEA/B,gBAAA,GAAc,SAAAA,CAAA,EAAS;EAErB,IAAI,OAAO1B,MAAA,KAAW,aAAa;IACjCzB,eAAA,OAAK+C,6BAAA,EAAAK,QAAA,EAALnD,IAAA;IACA;EACF;EACA,MAAMuH,YAAA,GAAe5H,YAAA,OAAKiD,OAAA,EAAQZ,MAAA,IAAUrC,YAAA,OAAK8C,OAAA,EAAQF,aAAA;EACzD,IAAIgF,YAAA,EAAc;IAGhB,IAAI5H,YAAA,OAAKkD,aAAA,GAAe;MACtB,IAAI,OAAO2E,kBAAA,KAAuB,aAAa;QAC7CA,kBAAA,CAAmBrB,MAAA,CAAOxG,YAAA,OAAKkD,aAAA,CAAa,CAAC;MAC/C,OAAO;QACL4E,YAAA,CAAatB,MAAA,CAAOxG,YAAA,OAAKkD,aAAA,CAAa,CAAC;MACzC;IACF;IACA9C,eAAA,OAAK+C,6BAAA,EAAAK,QAAA,EAALnD,IAAA;IACA;EACF;EAGA,IAAIL,YAAA,OAAKkD,aAAA,GAAe;IACtB;EACF;EAEA,IAAI,yBAAyBrB,MAAA,EAAQ;IACnCkC,YAAA,OAAKb,aAAA,EAAgB6E,mBAAA,CAAoB,MAAM;MAC7C3H,eAAA,OAAK+C,6BAAA,EAAAK,QAAA,EAALnD,IAAA;MACA0D,YAAA,OAAKb,aAAA,EAAgB;IACvB,CAAC;EACH,OAAO;IAELa,YAAA,OAAKb,aAAA,EAAgB8E,UAAA,CAAW,MAAM;MACpC5H,eAAA,OAAK+C,6BAAA,EAAAK,QAAA,EAALnD,IAAA;MACA0D,YAAA,OAAKb,aAAA,EAAgB;IACvB,GAAG,CAAC;EACN;AACF;AAEAM,QAAA,GAAM,SAAAA,CAAA,EAAS;EAEb,MAAMyE,WAAA,GAAc,CAAC,GAAGjI,YAAA,OAAKiD,OAAA,CAAO;EACpCc,YAAA,OAAKd,OAAA,EAAU,EAAC;EAEhBc,YAAA,OAAKb,aAAA,EAAgB;EAErB,IAAI+E,WAAA,CAAY5F,MAAA,KAAW,GAAG;IAC5B;EACF;EAEA,MAAM6F,YAAA,GAAeD,WAAA,CAClBE,MAAA,CAAOC,IAAA,IAAQA,IAAA,CAAK3C,IAAA,KAAS,OAAO,EACpChE,GAAA,CAAI2G,IAAA,IAASA,IAAA,CAAkD1C,KAAK;EAEvE,MAAM2C,UAAA,GAAaJ,WAAA,CAChBE,MAAA,CAAOC,IAAA,IAAQA,IAAA,CAAK3C,IAAA,KAAS,KAAK,EAClChE,GAAA,CAAI2G,IAAA,IAASA,IAAA,CAAkD1C,KAAK;EAEvE,IAAIwC,YAAA,CAAa7F,MAAA,GAAS,GAAG;IAC3B,MAAMiG,SAAA,GAAY,IAAIC,GAAA,CAAI,aAAavI,YAAA,OAAK8C,OAAA,EAAQD,QAAQ;IAC5D2F,KAAA,CAAMF,SAAA,EAAW;MACfG,OAAA,EAAS;QACP,gBAAgB;MAClB;MACAC,SAAA,EAAW;MACXC,MAAA,EAAQ;MAAA;MAERC,IAAA,EAAMlI,IAAA,CAAKC,SAAA,CAAU;QAAEkI,MAAA,EAAQX;MAAa,CAAC;IAC/C,CAAC,EAAEY,KAAA,CAAM,MAAM,MAAM;EACvB;EAEA,IAAIT,UAAA,CAAWhG,MAAA,GAAS,GAAG;IACzB,MAAM0G,OAAA,GAAU,IAAIR,GAAA,CAAI,YAAYvI,YAAA,OAAK8C,OAAA,EAAQD,QAAQ;IACzD2F,KAAA,CAAMO,OAAA,EAAS;MACbN,OAAA,EAAS;QACP,gBAAgB;MAClB;MACAC,SAAA,EAAW;MACXC,MAAA,EAAQ;MACRC,IAAA,EAAMlI,IAAA,CAAKC,SAAA,CAAU;QAAEqI,IAAA,EAAMX;MAAW,CAAC;IAC3C,CAAC,EAAES,KAAA,CAAM,MAAM,MAAM;EACvB;AACF;AAAA;AAAA;AAAA;AAKArF,WAAA,GAAS,SAAAA,CAAC1C,KAAA,EAAgChB,OAAA,EAA8B;EACtE,IAAI,CAAC,KAAKoF,OAAA,EAAS;IACjB;EACF;EAEA,IAAI,OAAOS,OAAA,CAAQqD,cAAA,KAAmB,aAAa;IACjDrD,OAAA,CAAQqD,cAAA,CAAe,qBAAqBlI,KAAK;IACjD6E,OAAA,CAAQsD,GAAA,CAAInJ,OAAO;IACnB6F,OAAA,CAAQuD,QAAA,CAAS;EACnB,OAAO;IACLvD,OAAA,CAAQsD,GAAA,CAAI,qBAAqBnI,KAAA,EAAOhB,OAAO;EACjD;AACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA2D,iBAAA,GAAe,SAAAA,CAAA,EAAG;EAChB,MAAMmD,WAAA,GAAc;IAClBzE,IAAA,EAAMpC,YAAA,OAAKgD,SAAA,EAAUoB,GAAA;IACrB4C,OAAA,EAAShH,YAAA,OAAKgD,SAAA,EAAUqB;EAC1B;EAEA,IAAI,OAAOxC,MAAA,KAAW,aAAa;IACjC,MAAMuH,eAAA,GAAkBvH,MAAA;IAExB,IAAIuH,eAAA,CAAgBC,KAAA,EAAO;MACzB,MAAMC,WAAA,GAAcF,eAAA,CAAgBC,KAAA;MAEpC,IAAI/G,yBAAA,CAA0BgH,WAAW,KAAKA,WAAA,CAAY1J,WAAA,CAAYiH,WAAA,EAAa;QACjF,MAAM;UAAEzE,IAAA;UAAM4E;QAAQ,IAAIsC,WAAA,CAAY1J,WAAA,CAAYiH,WAAA;QAElD,IAAIzE,IAAA,KAAS,QAAW;UACtByE,WAAA,CAAYzE,IAAA,GAAOA,IAAA;QACrB;QACA,IAAI4E,OAAA,KAAY,QAAW;UACzBH,WAAA,CAAYG,OAAA,GAAUA,OAAA;QACxB;MACF;IACF;EACF;EAEA,OAAOH,WAAA;AACT;AAAA;AAAA;AAAA;AAKAlD,iBAAA,GAAe,SAAAA,CAAC5C,KAAA,EAAgChB,OAAA,EAAoD;EAClG,MAAM8G,WAAA,GAAczG,eAAA,OAAK+C,6BAAA,EAAAO,iBAAA,EAALrD,IAAA;EAEpB,OAAO;IACLU,KAAA;IACAkG,EAAA,EAAIjH,YAAA,OAAKgD,SAAA,EAAUmB,YAAA,IAAgB;IACnCoF,EAAA,EAAIvJ,YAAA,OAAKgD,SAAA,EAAUyB,YAAA,IAAgB;IACnCL,GAAA,EAAKyC,WAAA,CAAYzE,IAAA;IACjB2E,IAAA,EAAMF,WAAA,CAAYG,OAAA;IAClB,IAAIhH,YAAA,OAAKgD,SAAA,EAAUsB,cAAA,GAAiB;MAAEpD,EAAA,EAAIlB,YAAA,OAAKgD,SAAA,EAAUsB;IAAe,IAAI,CAAC;IAC7E,IAAItE,YAAA,OAAKgD,SAAA,EAAU0B,SAAA,GAAY;MAAE1D,EAAA,EAAIhB,YAAA,OAAKgD,SAAA,EAAU0B;IAAU,IAAI,CAAC;IACnE3E;EACF;AACF;AAAA;AAAA;AAAA;AAAA;AAMA6D,kBAAA,GAAgB,SAAAA,CAAC0D,OAAA,EAAkD;EACjE,IAAIA,OAAA,KAAY,QAAQ,OAAOA,OAAA,KAAY,aAAa;IACtD,OAAO;EACT;EACA,IAAI,OAAOA,OAAA,KAAY,UAAU;IAC/B,OAAO;EACT;EACA,IAAI;IACF,MAAMkC,OAAA,GAAU9I,IAAA,CAAKkB,KAAA,CAAMlB,IAAA,CAAKC,SAAA,CAAU2G,OAAO,CAAC;IAClD,IAAIkC,OAAA,IAAW,OAAOA,OAAA,KAAY,YAAY,CAACC,KAAA,CAAMC,OAAA,CAAQF,OAAO,GAAG;MACrE,OAAOA,OAAA;IACT;IACA,OAAO;EACT,QAAQ;IACN,OAAO;EACT;AACF;;;AC9bF,IAAMG,uBAAA,GAA0B;AAChC,IAAMC,sBAAA,GAAyB;AAC/B,IAAMC,mBAAA,GAAsB;AAkB5B,SAASC,6BAA6B/I,KAAA,EAAuE;EAC3G,OAAO,UACLgJ,SAAA,EACAC,KAAA,EACAC,iBAAA,EAC2C;IAC3C,OAAO;MACLlJ,KAAA;MACAwE,iBAAA,EAAmBsE,mBAAA;MACnB9J,OAAA,EAAS;QACPgK,SAAA;QACAG,cAAA,EAAgBC,OAAA,CAAQH,KAAA,EAAOI,UAAU;QACzCC,SAAA,EAAWF,OAAA,CAAQH,KAAA,EAAOI,UAAA,EAAYC,SAAS;QAC/CC,QAAA,EAAUH,OAAA,CAAQH,KAAA,EAAOI,UAAA,EAAYE,QAAQ;QAC7CC,SAAA,EAAWJ,OAAA,CAAQH,KAAA,EAAOI,UAAA,EAAYG,SAAS;QAC/C,GAAGN;MACL;IACF;EACF;AACF;AAWO,SAASO,8BACdT,SAAA,EACAC,KAAA,EACAC,iBAAA,EAC2C;EAC3C,OAAOH,4BAAA,CAA6BH,uBAAuB,EAAEI,SAAA,EAAWC,KAAA,EAAOC,iBAAiB;AAClG;AAWO,SAASQ,6BACdV,SAAA,EACAC,KAAA,EACAC,iBAAA,EAC2C;EAC3C,OAAOH,4BAAA,CAA6BF,sBAAsB,EAAEG,SAAA,EAAWC,KAAA,EAAOC,iBAAiB;AACjG;AAYO,SAASS,sBACdX,SAAA,EACAC,KAAA,GAAsC,CAAC,GACG;EAC1C,OAAO;IACLjJ,KAAA,EAAO4I,uBAAA;IACPpE,iBAAA,EAAmBsE,mBAAA;IACnB9J,OAAA,EAAS;MACPgK,SAAA;MACA,GAAGC;IACL;EACF;AACF;;;ACjGA,IAAMW,mBAAA,GAAsB;AAC5B,IAAMC,oBAAA,GAAsB;AASrB,SAASC,kBACdlC,MAAA,EACA5I,OAAA,EACsC;EACtC,OAAO;IACLgB,KAAA,EAAO4J,mBAAA;IACPpF,iBAAA,EAAmBqF,oBAAA;IACnB7K,OAAA,EAAS;MACP4I,MAAA;MACA,GAAG5I;IACL;EACF;AACF;;;ACtBA,IAAM+K,wBAAA,GAA2B;AACjC,IAAMC,oBAAA,GAAsB;AAOrB,SAASC,uBAAuBjL,OAAA,EAA4E;EACjH,OAAO;IACLgB,KAAA,EAAO+J,wBAAA;IACPvF,iBAAA,EAAmBwF,oBAAA;IACnBhL;EACF;AACF;;;ACdO,IAAMkL,iBAAA,GAAoB;AAC1B,IAAMC,oBAAA,GAAsB;AAgB5B,SAASC,gBAAgBf,UAAA,EAA6D;EAC3F,MAAMrK,OAAA,GAAUqL,iBAAA,CAAkBhB,UAAU;EAE5C,OAAO;IACLrJ,KAAA,EAAOkK,iBAAA;IACP1F,iBAAA,EAAmB2F,oBAAA;IACnBnL;EACF;AACF;AAOA,SAASqL,kBAAkBhB,UAAA,EAA0C;EACnE,IAAI,CAACA,UAAA,IAAc,OAAOA,UAAA,KAAe,UAAU;IACjD,OAAO,CAAC;EACV;EAGA,MAAMiB,aAAA,GAAgBjB,UAAA,CAAWkB,KAAA,IAASlB,UAAA,CAAWC,SAAA;EAErD,IAAI,CAACgB,aAAA,EAAe;IAClB,OAAO,CAAC;EACV;EAEA,IAAIE,SAAA;EAEJ,IAAI9B,KAAA,CAAMC,OAAA,CAAQ2B,aAAa,GAAG;IAEhC,WAAWC,KAAA,IAASD,aAAA,EAAe;MACjC,MAAMjJ,IAAA,GAAOoJ,gBAAA,CAAiBF,KAAK;MACnC,IAAIlJ,IAAA,EAAM;QACRmJ,SAAA,GAAYnJ,IAAA;QACZ;MACF;IACF;EACF,OAAO;IACLmJ,SAAA,GAAYC,gBAAA,CAAiBH,aAAa;EAC5C;EAEA,OAAO;IAAEE;EAAU;AACrB;AAOA,SAASC,iBAAiBF,KAAA,EAAsC;EAC9D,IAAI,OAAOA,KAAA,KAAU,UAAU;IAC7B,OAAOA,KAAA;EACT;EAEA,IAAI,OAAOA,KAAA,KAAU,YAAYA,KAAA,KAAU,MAAM;IAE/C,IAAI,UAAUA,KAAA,IAAS,OAAOA,KAAA,CAAMlJ,IAAA,KAAS,UAAU;MACrD,OAAOkJ,KAAA,CAAMlJ,IAAA;IACf;EACF;EAEA,OAAO;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}