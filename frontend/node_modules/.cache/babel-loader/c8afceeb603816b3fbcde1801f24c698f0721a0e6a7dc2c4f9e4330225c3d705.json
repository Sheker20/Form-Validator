{"ast":null,"code":"import rules from \"./validation/rules\";\n\n/**\n * Mock API that \"extracts\" fields from an uploaded CMS-1500 form and applies validation rules.\n * This is a simplified simulation to help the frontend demonstrate flagging using the provided rules.\n */\n\nconst sampleExtracted = {\n  subscriberFirstName: \"John\",\n  subscriberLastName: \"Doe\",\n  dob: \"13-45-2020\",\n  gender: \"\",\n  policyNumber: \"A123456\",\n  npi: \"1234567890\",\n  serviceDate: \"2025-07-32\",\n  cpt: \"99213\",\n  icd: \"Z00.00\",\n  units: \"0\",\n  placeOfService: \"11\",\n  signature: \"\"\n};\nfunction sleep(ms) {\n  return new Promise(res => setTimeout(res, ms));\n}\nfunction applyRules(extracted) {\n  const fields = Object.keys(extracted).map(k => {\n    const value = extracted[k];\n    // find matching rules by field name\n    const matched = rules.filter(r => r.fields.includes(k));\n    let status = \"ok\";\n    let issue = \"\";\n    let suggestion = \"\";\n    for (const r of matched) {\n      if (r.type === \"missing\" && (!value || String(value).trim().length === 0)) {\n        status = status === \"error\" ? \"error\" : \"error\";\n        issue = r.message;\n        suggestion = r.suggestion;\n      }\n      if (r.type === \"format\") {\n        if (!r.regex.test(String(value))) {\n          status = status === \"error\" ? \"error\" : \"error\";\n          issue = r.message;\n          suggestion = r.suggestion;\n        }\n      }\n      if (r.type === \"cross\" && r.check) {\n        try {\n          const res = r.check(extracted);\n          if (res) {\n            status = res.status || status;\n            issue = res.message || issue;\n            suggestion = res.suggestion || suggestion;\n          }\n        } catch (e) {}\n      }\n    }\n    return {\n      field: k,\n      label: k,\n      value,\n      status,\n      issue,\n      suggestion\n    };\n  });\n  return {\n    summary: `${fields.length} fields — ${fields.filter(f => f.status === 'error').length} errors, ${fields.filter(f => f.status === 'warn').length} warnings`,\n    fields\n  };\n}\nexport default {\n  async uploadAndValidate(file) {\n    await sleep(800);\n    // in real app we'd call OCR and parser; here use sampleExtracted as base\n    const result = applyRules(sampleExtracted);\n    return result;\n  }\n};","map":{"version":3,"names":["rules","sampleExtracted","subscriberFirstName","subscriberLastName","dob","gender","policyNumber","npi","serviceDate","cpt","icd","units","placeOfService","signature","sleep","ms","Promise","res","setTimeout","applyRules","extracted","fields","Object","keys","map","k","value","matched","filter","r","includes","status","issue","suggestion","type","String","trim","length","message","regex","test","check","e","field","label","summary","f","uploadAndValidate","file","result"],"sources":["D:/hidc project/hidc project/src/mockApi.js"],"sourcesContent":["import rules from \"./validation/rules\";\n\n/**\n * Mock API that \"extracts\" fields from an uploaded CMS-1500 form and applies validation rules.\n * This is a simplified simulation to help the frontend demonstrate flagging using the provided rules.\n */\n\nconst sampleExtracted = {\n  subscriberFirstName: \"John\",\n  subscriberLastName: \"Doe\",\n  dob: \"13-45-2020\",\n  gender: \"\",\n  policyNumber: \"A123456\",\n  npi: \"1234567890\",\n  serviceDate: \"2025-07-32\",\n  cpt: \"99213\",\n  icd: \"Z00.00\",\n  units: \"0\",\n  placeOfService: \"11\",\n  signature: \"\"\n};\n\nfunction sleep(ms) { return new Promise((res) => setTimeout(res, ms)); }\n\nfunction applyRules(extracted) {\n  const fields = Object.keys(extracted).map((k) => {\n    const value = extracted[k];\n    // find matching rules by field name\n    const matched = rules.filter(r => r.fields.includes(k));\n    let status = \"ok\";\n    let issue = \"\";\n    let suggestion = \"\";\n    for (const r of matched) {\n      if (r.type === \"missing\" && (!value || String(value).trim().length===0)) {\n        status = status === \"error\" ? \"error\" : \"error\";\n        issue = r.message;\n        suggestion = r.suggestion;\n      }\n      if (r.type === \"format\") {\n        if (!r.regex.test(String(value))) {\n          status = status === \"error\" ? \"error\" : \"error\";\n          issue = r.message;\n          suggestion = r.suggestion;\n        }\n      }\n      if (r.type === \"cross\" && r.check) {\n        try {\n          const res = r.check(extracted);\n          if (res) {\n            status = res.status || status;\n            issue = res.message || issue;\n            suggestion = res.suggestion || suggestion;\n          }\n        } catch(e) {}\n      }\n    }\n    return {\n      field: k,\n      label: k,\n      value,\n      status,\n      issue,\n      suggestion\n    };\n  });\n\n  return { summary: `${fields.length} fields — ${fields.filter(f=>f.status==='error').length} errors, ${fields.filter(f=>f.status==='warn').length} warnings`, fields };\n}\n\nexport default {\n  async uploadAndValidate(file) {\n    await sleep(800);\n    // in real app we'd call OCR and parser; here use sampleExtracted as base\n    const result = applyRules(sampleExtracted);\n    return result;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}